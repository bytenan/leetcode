// Source : https://leetcode.cn/problems/maximum-product-subarray/
// Author : Yanan Wang
// Date   : 2023-05-31

/**
 * 动态规划类题目的一般步骤：
 *   1. 状态表示
 *        设f[i]表示以i结尾的所有连续子数组中的乘积最大值
 *        设g[i]表示以i结尾的所有连续子数组中的乘积最小值
 *   2. 状态转移方程
 *        以i结尾的连续子数组有两种状态：
 *     ----------------------------------------
 *     |     nums [ *, *, *, *]                
 *     |                     -     -第一种状态   
 *     |                  ++++                 
 *     |               +++++++     +第二种状态   
 *     |            ++++++++++                 
 *     ----------------------------------------
 *   -----------------------------------------------------------------------------------
 *  |         |- 状态一  f[i] = nums[i]
 *  |   f[i] -|
 *  |         |         |- 假设nums[i] > 0，f[i] = f[i - 1] * nums[i]
 *  |         |- 状态二 -|
 *  |                   |- 假设nums[i] < 0，f[i] = g[i - 1] * nums[i]
 *  |   
 *  |         |- 状态一  g[i] = nums[i]
 *  |   g[i] -|
 *  |         |         |- 假设nums[i] > 0，g[i] = g[i - 1] * nums[i]
 *  |         |- 状态二 -|
 *  |                   |- 假设nums[i] < 0，g[i] = f[i - 1] * nums[i]
 *   -----------------------------------------------------------------------------------   
 *   3. 初始化
 *        可以手动初始化f[0] = g[0] = 1，
 *        也可以选择f和g前面开一个空间，当选择该方法时，要注意两点：1、多开空间的数不影响后面的填表；2、注意下标的映射关系。
 *          针对第1点，f[0] = g[0] = 1
 *   4. 填表顺序
 *        一起从左向右
 *   5. 返回值
 *        题目找的是乘积最大，那么就返回f中的最大值。
 */

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n + 1, 1);        
        vector<int> g(n + 1, 1); 
        int result = INT_MIN;
        for (int i = 1; i <= n; ++i)
        {
            f[i] = max(max(nums[i - 1], f[i - 1] * nums[i - 1]), g[i - 1] * nums[i - 1]);
            g[i] = min(min(nums[i - 1], g[i - 1] * nums[i - 1]), f[i - 1] * nums[i - 1]);
            result = max(result, f[i]);
        }
        return result;
    }
};