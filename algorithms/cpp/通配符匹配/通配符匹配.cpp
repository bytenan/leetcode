// Source : https://leetcode.cn/problems/wildcard-matching/
// Author : Yanan Wang
// Date   : 2023-07-09

/**
 * 动态规划类题目的一般步骤：
 *    1. 状态表示
 *         设dp[i][j]表示s在[0,i]区间并且p在[0,j]区间能否完全匹配。
 *    2. 状态转移方程
 *         根据最后一个位置的状况，分情况讨论: 
 *            ①假设p[j]是普通字符, 那么dp[i][j] = s[i] == p[j] && dp[i-1][j-1];
 *            ②假设p[j]是字符'?', 那么dp[i][j] = dp[i-1][j-1];
 *            ③假设p[j]是字符'*', 那么再分情况讨论:
 *                 ①假设’*‘匹配空串, 那么dp[i][j] = dp[i][j-1];
 *                 ②假设'*'匹配s[i], 那么dp[i][j] = dp[i-1][j-1];
 *                 ③假设'*'匹配s[i-1] -> s[i], 那么dp[i][j] = dp[i-2][j-1];
 *                 ④假设'*'匹配s[i-2] -> s[i], 那么dp[i][j] = dp[i-3][j-1];
 *                      ...
 *            如果完全按照以上状态转移方程解本题，虽然能过，但时间复杂度已达到O(N^3)
 *            所以要优化第三层循环，有两种方法：
 *                 ①数学方法:  
 *                           ∵ dp[i][j] = dp[i][j-1] || dp[i-1][j-1] || dp[i-2][j-1] || dp[i-3][j-1] || ...
 *                          又∵ dp[i-1][j] = dp[i-1][j-1] || dp[i-2][j-1] || dp[i-3][j-1] || ...
 *                           ∴ dp[i][j] = dp[i][j-1] || dp[i-1][j]; 
 *                 ②根据状态表示和实际情况，优化状态转移方程:
 *                           如果'*'匹配空串, 那么dp[i][j] = dp[i][j-1];
 *                           如果'*'匹配一个字符, 那么dp[i][j] = dp[i-1][j]; 注意，此时'*'并不丢掉，而是继续去匹配
 *                                  如果'*'又匹配空串, 那么dp[i-1][j] = dp[i-1][j-1];
 *                                  如果'*'又匹配一个字符, 那么dp[i-1][j] = dp[i-2][j]; 注意，此时'*'并不丢掉，而是继续去匹配
 *                                           如果'*'又又匹配空串, 那么dp[i-2][j] = dp[i-2][j-1];
 *                                           如果'*'又又匹配一个字符, 那么dp[i-2][j] = dp[i-3][j]; 注意，此时'*'并不丢掉，而是继续去匹配     
 *                                                     ...
 *                           上述的状态转移能够归纳为：dp[i][j] = dp[i][j-1] || dp[i-1][j];
 *    3. 初始化
 *         字符串类题目的初始化要注意三点:
 *            ①引入空串的概念;
 *            ②在多开辟行或列时, 要注意填入的数值不能影响后续填表的正确性;
 *                 当s为空串时，p只能是为‘*’时，才为true，所以将dp第一行出现普通字符和‘?’之前的位置填true，其余位置填false;
 *                 当p为空串时，s只能是为空串时，才为true，所以将dp第一列的第一个位置填true，其余位置填flase。
 *            ③在多开辟行或列时，要注意dp表和字符串下标的映射关系（在字符串的前面随意添加一个字符，就可以无视映射关系）;
 *    4. 填表顺序
 *         ∵ 填dp[i][j]可能需要dp[i][j-1]或者dp[i-1][j]或者dp[i-1][j-1]
 *         ∴ 从上往下填每一行，从左向右填每一列
 *    5. 返回值
 *         dp的最后一个值
 */

class Solution {
public:
    bool isMatch(string s, string p) {
        s = ' ' + s;
        p = ' ' + p;
        int m = s.size();
        int n = p.size();
        vector<vector<bool>> dp(m, vector<bool>(n, false));
        dp[0][0] = true;
        for (int j = 1; j < n; ++j) {
            if (p[j] != '*') {
                break;
            }
            dp[0][j] = true;
        }
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                if (p[j] == '*') {
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                } else if (p[j] == '?' || s[i] == p[j]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } 
            }
        }
        return dp[m - 1][n - 1];
    }
};