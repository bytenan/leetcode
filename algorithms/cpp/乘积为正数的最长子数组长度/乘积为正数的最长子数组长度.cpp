// Source : https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/
// Author : Yanan Wang
// Date   : 2023-05-31

/**
 * 动态规划类题目的一般步骤：
 *   1. 状态表示
 *        设f[i]表示以i结尾的子数组中乘积为正数的最长长度
 *        设g[i]表示以i结尾的子数组中乘积为负数的最长长度
 *   2. 状态转移方程
 *        以i结尾的连续子数组有两种状态：
 *     ----------------------------------------
 *     |     nums [ *, *, *, *]                
 *     |                     -     -第一种状态   
 *     |                  ++++                 
 *     |               +++++++     +第二种状态   
 *     |            ++++++++++                 
 *     ----------------------------------------
 *   -----------------------------------------------------------------------------------
 *  |                   |- 假设nums[i] > 0，f[i] = 1
 *  |         |- 状态一  |
 *  |         |         |- 假设nums[i] < 0，f[i] = 0
 *  |   f[i] -|
 *  |         |         |- 假设nums[i] > 0，f[i] = f[i - 1] + 1
 *  |         |- 状态二 -|
 *  |                   |- 假设nums[i] < 0，f[i] = g[i - 1] == 0 ? 0 : (g[i - 1] + 1)
 *  |   
 *  |                   |- 假设nums[i] > 0，g[i] = 0
 *  |         |- 状态一  |
 *  |         |         |- 假设nums[i] < 0，g[i] = 1
 *  |   g[i] -|
 *  |         |         |- 假设nums[i] > 0，g[i] = g[i - 1] == 0 ? 0 : (g[i - 1] + 1)
 *  |         |- 状态二 -|
 *  |                   |- 假设nums[i] < 0，g[i] = f[i - 1] + 1
 *   -----------------------------------------------------------------------------------
 *                                          |
 *                                          | 可转化为
 *                                         \./
 *   -----------------------------------------------------------------------------------
 *  |         |- nums[i] > 0， f[i] = f[i - 1] + 1
 *  |   f[i] -|
 *  |         |- nums[i] < 0， f[i] = g[i - 1] == 0 ? 0 : (g[i - 1] + 1)
 *  |   
 *  |         |- nums[i] > 0， g[i] = g[i - 1] == 0 ? 0 : (g[i - 1] + 1)
 *  |   g[i] -|
 *  |         |- nums[i] < 0， g[i] = f[i - 1] + 1
 *   -----------------------------------------------------------------------------------
 *   3. 初始化
 *        可以选择手动初始化f[0]和g[0]，
 *        也可以选择f和g前面开一个空间，当选择该方法时，要注意两点：1、多开空间的数不影响后面的填表；2、注意下标的映射关系。
 *          针对第1点，f[0] = g[0] = 1
 *   4. 填表顺序
 *        一起从左向右
 *   5. 返回值
 *        题目要求返回乘积为正数的最长子数组长度，那么就返回f中的最大值。
 */

class Solution {
public:
    int getMaxLen(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n + 1);
        vector<int> g(n + 1);
        int result = INT_MIN;
        for (int i = 1; i <= n; ++i)
        {
            if (nums[i - 1] > 0)
            {
                f[i] = f[i - 1] + 1;
                g[i] = g[i - 1] == 0 ? 0 : g[i - 1] + 1;
            }
            else if (nums[i - 1] < 0)
            {
                g[i] = f[i - 1] + 1;
                f[i] = g[i - 1] == 0 ? 0 : g[i - 1] + 1;
            }
            result = max(result, f[i]);
        }
        return result;
    }
};