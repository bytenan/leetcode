// Source : https://leetcode.cn/problems/regular-expression-matching/
// Author : Yanan Wang
// Date   : 2023-07-10

/**
 * 动态规划类题目的一般步骤：
 *    1. 状态表示
 *         设dp[i][j]表示s在[0,i]区间并且p在[0,j]区间能否完全匹配。
 *    2. 状态转移方程
 *         根据最后一个位置的状况，分情况讨论: 
 *            ①假设p[j]是普通字符, 那么dp[i][j] = s[i] == p[j] && dp[i-1][j-1];
 *            ②假设p[j]是字符'.', 那么dp[i][j] = dp[i-1][j-1];
 *            ③假设p[j]是字符'*', 那么再分情况讨论:
 *                 ①假设p[j-1]是'.', 并且'*'匹配空串, 此时dp[i][j] = dp[i][j-2];
 *                                   并且'*'匹配一个'.', 此时dp[i][j] = dp[i-1][j-2];
 *                                   并且'*'匹配二个'.', 此时dp[i][j] = dp[i-2][j-2];   
 *                                   并且'*'匹配三个'.', 此时dp[i][j] = dp[i-3][j-2];   
 *                                   ...
 *                 ②假设p[j-1]是普通字符, 并且'*'匹配空串, 那么dp[i][j] = dp[i][j-2];
 *                                       并且'*'匹配一个普通字符, 此时如果s[i]==p[j-1], 那么dp[i][j] = dp[i-1][j-2];
 *                                       并且'*'匹配二个普通字符, 此时如果s[i-1]==p[j-1], 那么dp[i][j] = dp[i-2][j-2];
 *                                       并且'*'匹配三个普通字符, 此时如果s[i-2]==p[j-1], 那么dp[i][j] = dp[i-3][j-2];
 *                                       ...
 *            以上状态转移方程的时间复杂度已达到O(N^3), 所以要进行优化。
 *            所以要优化第三层循环，有两种方法(p[j-1]是'.'和p[j-1]是普通字符这两种情况优化方法一样, 拿p[j-1]=='.'举例):
 *                 ①数学方法:  
 *                           ∵ dp[i][j] = dp[i][j-2] || dp[i-1][j-2] || dp[i-2][j-2] || dp[i-3][j-2] || ...
 *                          又∵ dp[i-1][j] = dp[i-1][j-2] || dp[i-2][j-2] || dp[i-3][j-2] || ...
 *                           ∴ dp[i][j] = dp[i][j-2] || dp[i-1][j]; 
 *                 ②根据状态表示和实际情况，优化状态转移方程:
 *                           如果'*'匹配空串, 那么dp[i][j] = dp[i][j-2];
 *                           如果'*'匹配一个普通字符, 那么dp[i][j] = dp[i-1][j-2]; 注意，此时'*'并不丢掉，而是继续去匹配
 *                                  如果'*'又匹配空串, 那么dp[i-1][j] = dp[i-1][j-2];
 *                                  如果'*'又匹配一个字符, 那么dp[i-1][j] = dp[i-2][j-2]; 注意，此时'*'并不丢掉，而是继续去匹配
 *                                           如果'*'又又匹配空串, 那么dp[i-2][j] = dp[i-2][j-2];
 *                                           如果'*'又又匹配一个字符, 那么dp[i-2][j] = dp[i-3][j-2]; 注意，此时'*'并不丢掉，而是继续去匹配     
 *                                                     ...
 *                           上述的状态转移能够归纳为：dp[i][j] = dp[i][j-2] || dp[i-1][j];
 *        ⭐️综上所述：上面的状态转移方程可归纳为以下:
 *               if (p[j] == '*') { dp[i][j] = dp[i][j - 2] || (p[j - 1] == '.' || p[j - 1] == s[i]) && dp[i - 1][j]; }
 *               else { dp[i][j] = (p[j] == '.' || s[i] == p[j]) && dp[i - 1][j - 1]; }
 *    3. 初始化
 *         字符串类题目的初始化要注意三点:
 *            ①引入空串的概念;
 *            ②在多开辟行或列时, 要注意填入的数值不能影响后续填表的正确性;
 *                 当s为空串时，p只能是从开始时就以这样的形态(_*_*_*...), 直到该形态破坏掉, 保持该形态的那个位置为true, 后面全填false。(因为‘*’仅当匹配前一个字符为空串时, p和s才能够匹配上)
 *                 当p为空串时，s只能是为空串时，才为true，所以将dp第一列的第一个位置填true，其余位置填flase。
 *            ③在多开辟行或列时，要注意dp表和字符串下标的映射关系（在字符串的前面随意添加一个字符，就可以无视映射关系）;
 *    4. 填表顺序
 *         ∵ 填dp[i][j]可能需要dp[i-1][j-1]或者dp[i][j-2]或者dp[i-1][j]
 *         ∴ 从上往下填每一行，从左向右填每一列
 *    5. 返回值
 *         dp的最后一个值
 */

class Solution {
public:
    bool isMatch(string s, string p) {
        s = ' ' + s;
        p = ' ' + p;
        int m = s.size();
        int n = p.size();
        vector<vector<int>> dp(m, vector<int>(n, false));
        dp[0][0] = true;
        for (int j = 2; j < n; j += 2) {
            if (p[j] == '*') {
                dp[0][j] = true;
            } else {
                break;
            }
        }
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                if (p[j] == '*') {
                    dp[i][j] = dp[i][j - 2] || (p[j - 1] == '.' || p[j - 1] == s[i]) && dp[i - 1][j]; 
                } else {
                    dp[i][j] = (p[j] == '.' || s[i] == p[j]) && dp[i - 1][j - 1]; 
                }
            }
        }
        return dp[m - 1][n - 1];
    }
};